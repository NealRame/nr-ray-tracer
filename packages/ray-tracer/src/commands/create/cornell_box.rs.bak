use std::collections::VecDeque;
use std::fs;
use std::f64::consts::PI;
use std::io;
use std::io::Write;

use anyhow::Result;

use glam::DVec3;

use crate::cli::CameraConfig;
use crate::scene_config::*;

use super::create::*;

// fn generate_box(
//     a: DVec3, b: DVec3,
//     material: usize,
// ) -> Vec<ObjectConfig> {
//     let [min_x, min_y, min_z] = a.min(b).to_array();
//     let [max_x, max_y, max_z] = a.max(b).to_array();

//     let dx = (max_x - min_x)*DVec3::X;
//     let dy = (max_y - min_y)*DVec3::Y;
//     let dz = (max_z - min_z)*DVec3::Z;

//     vec![
//         ObjectConfig::Group { count: 6 },
//         ObjectConfig::Quad {
//             top_left: DVec3::new(min_x, min_y, max_z),
//             u: dx,
//             v: dy,
//             material
//         },
//         ObjectConfig::Quad {
//             top_left: DVec3::new(max_x, min_y, max_z),
//             u: -dz,
//             v: dy,
//             material
//         },
//         ObjectConfig::Quad {
//             top_left: DVec3::new(max_x, min_y, min_z),
//             u: -dx,
//             v: dy,
//             material
//         },
//         ObjectConfig::Quad {
//             top_left: DVec3::new(min_x, min_y, min_z),
//             u: dz,
//             v: dy,
//             material
//         },
//         ObjectConfig::Quad {
//             top_left: DVec3::new(min_x, max_y, max_z),
//             u: dx,
//             v: -dz,
//             material
//         },
//         ObjectConfig::Quad {
//             top_left: DVec3::new(min_x, min_y, min_z),
//             u: dx,
//             v: dz,
//             material
//         },
//     ]
// }

pub fn run(args: &CreateArgs) -> Result<()> {
    let textures = vec![
        TextureConfig::SolidColor { color: 15.*DVec3::ONE },               // 0: light
        // TextureConfig::SolidColor { color: DVec3::new(0.65, 0.05, 0.05) }, // 1: red
        // TextureConfig::SolidColor { color: DVec3::new(0.12, 0.45, 0.15) }, // 2: green
        // TextureConfig::SolidColor { color: DVec3::new(0.73, 0.73, 0.73) }, // 3: white
        // TextureConfig::SolidColor { color: DVec3::new(0.93, 1.00, 0.60) }, // 4:
        // TextureConfig::SolidColor { color: DVec3::new(0.00, 0.82, 1.00) }, // 5:
    ].into();

    let materials = vec![
        MaterialConfig::DiffuseLight { texture: 0 },       // 0:
        // MaterialConfig::Lambertian { texture: 1 },         // 1:
        // MaterialConfig::Lambertian { texture: 2 },         // 2:
        // MaterialConfig::Lambertian { texture: 3 },         // 3:
        // MaterialConfig::Lambertian { texture: 4 },         // 4:
        // MaterialConfig::Metal { fuzz: 0.025, texture: 5 }, // 5:
    ].into();

    let mut objects = VecDeque::new();

    // objects.push_back(ObjectConfig::Quad {
    //     top_left: 555.0*DVec3::X,
    //     u: 555.0*DVec3::Y,
    //     v: 555.0*DVec3::Z,
    //     material: 2,
    // });
    // objects.push_back(ObjectConfig::Quad {
    //     top_left: DVec3::ZERO,
    //     u: 555.0*DVec3::Y,
    //     v: 555.0*DVec3::Z,
    //     material: 1,
    // });
    // objects.push_back(ObjectConfig::Quad {
    //     top_left: DVec3::ZERO,
    //     u: 555.0*DVec3::X,
    //     v: 555.0*DVec3::Z,
    //     material: 3,
    // });
    // objects.push_back(ObjectConfig::Quad {
    //     top_left: 555.0*DVec3::ONE,
    //     u: 555.0*DVec3::NEG_X,
    //     v: 555.0*DVec3::NEG_Z,
    //     material: 3,
    // });
    // objects.push_back(ObjectConfig::Quad {
    //     top_left: 555.0*DVec3::Z,
    //     u: 555.0*DVec3::X,
    //     v: 555.0*DVec3::Y,
    //     material: 3,
    // });
    objects.push_back(ObjectConfig::Quad {
        top_left: DVec3::new(343.0, 554.0, 332.0),
        u: 130.0*DVec3::NEG_X,
        v: 105.0*DVec3::NEG_Z,
        material: 0,
    });

    // objects.push_back(ObjectConfig::Translate { offset: DVec3::new(130.0, 0.0, 65.0) });
    // objects.push_back(ObjectConfig::RotateY { angle: -18.0*PI/180.0 });
    // objects.extend(generate_box(
    //     DVec3::ZERO,
    //     DVec3::new(165.0, 165.0, 165.0),
    //     4,
    // ));

    // objects.push_back(ObjectConfig::Translate { offset: DVec3::new(265.0, 0.0, 295.0) });
    // objects.push_back(ObjectConfig::RotateY { angle: 15.0*PI/180.0 });
    // objects.extend(generate_box(
    //     DVec3::ZERO,
    //     DVec3::new(165.0, 330.0, 165.0),
    //     5,
    // ));

    let mut camera = CameraConfig {
        background_color: Some(0.01*DVec3::ONE),
        look_from: Some(DVec3::new(278.0, 278.0, -800.0)),
        look_at: Some(DVec3::new(278.0, 278.0, 0.0)),
        field_of_view: Some((40.*PI)/180.),
        ray_max_bounces: Some(50),
        samples_per_pixel: Some(100),
        ..CameraConfig::default()
    };

    camera.merge_with(&args.camera);

    let scene_config = SceneConfig {
        camera,
        textures,
        materials,
        objects,
    };

    let contents = match args.format {
        SceneConfigFormat::Json => serde_json::to_string_pretty(&scene_config)?,
        SceneConfigFormat::Toml => toml::to_string_pretty(&scene_config)?,
    };

    if let Some(output) = args.output.as_ref() {
        fs::write(output, &contents)?
    } else {
        io::stdout().write_all(contents.as_bytes())?;
    }

    Ok(())
}
